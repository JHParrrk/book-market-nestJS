### 1. 모듈 (Module) 기반의 명확한 구조

#### **개념 (Concept)**
**모듈(@Module)**은 관련된 기능들을 하나로 묶는 "기능 상자"입니다. 각 모듈은 컨트롤러(요청 처리), 서비스(비즈니스 로직), 프로바이더 등을 포함하며, 자체적으로 캡슐화됩니다. 이를 통해 애플리케이션의 각 부분을 독립적으로 개발하고 관리할 수 있어 구조가 매우 명확해집니다.

#### **실행 흐름 (Execution Flow)**
1. **애플리케이션 시작**: NestJS는 `main.ts`에서 `AppModule`을 로드하며 시작됩니다.
2. **모듈 트리 구성**: `AppModule`은 애플리케이션의 "뿌리 모듈"로서, 다른 모든 기능 모듈들을 `imports` 배열에 등록합니다.

```typescript
// src/app.module.ts
// ...
import { UsersModule } from './users/users.module';
import { AuthModule } from './auth/auth.module';

@Module({
  imports: [
    // ...
  ],
})
export class AppModule {}
```

3. **기능 단위 로드**: `AppModule`이 `UsersModule`을 불러오면, `UsersModule`에 정의된 컨트롤러와 서비스가 애플리케이션에 등록됩니다.

```typescript
// src/users/users.module.ts
@Module({
  imports: [TypeOrmModule.forFeature([User]), JwtModule.registerAsync(...)],
  controllers: [UsersController], // 이 모듈의 요청/응답 담당자
  providers: [UsersService],      // 이 모듈의 비즈니스 로직 담당자
  exports: [UsersService],        // 다른 모듈에서도 UsersService를 쓸 수 있게 공개
})
export class UsersModule {}
```

- **`controllers`**: `UsersController`가 HTTP 요청을 처리할 수 있게 됩니다.
- **`providers`**: `UsersService`가 의존성 주입을 통해 다른 곳에서 사용될 수 있도록 준비됩니다.

---

### 2. 의존성 주입 (Dependency Injection, DI)

#### **개념 (Concept)**
의존성 주입은 클래스가 필요로 하는 의존 객체(예: 서비스)를 직접 생성하지 않고, 외부(NestJS 프레임워크)로부터 "주입"받는 디자인 패턴입니다. 이를 통해 클래스 간의 결합도가 낮아져 코드의 재사용성과 테스트 용이성이 크게 향상됩니다.

#### **실행 흐름 (Execution Flow)**
1. **서비스 등록**: `UsersService` 클래스 상단에 `@Injectable()` 데코레이터가 붙어 있어, 이 서비스가 "주입 가능한" 대상임을 NestJS에 알립니다.
2. **주입 요청**: `UsersController`는 생성자(`constructor`)에서 `UsersService`를 타입으로 선언하여 주입을 요청합니다.

```typescript
// src/users/users.controller.ts
import { UsersService } from './users.service';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {
    // NestJS가 이 생성자를 보고, 미리 준비해 둔 UsersService의 인스턴스를 주입합니다.
  }
}
```

3. **요청 처리 시 사용**: `/users/register` 요청이 들어오면, `register` 메서드는 `this.usersService`를 통해 `UsersService`의 `register` 메서드를 호출합니다. `UsersController`는 `UsersService`가 어떻게 생성되었는지 전혀 신경 쓸 필요가 없습니다.

---

### 3. TypeORM 통합 (강력한 ORM)

#### **개념 (Concept)**
`@Entity` 데코레이터로 클래스를 정의하면, TypeORM이 해당 클래스를 데이터베이스 테이블과 매핑합니다. 그 후 **`Repository`** 패턴을 통해 SQL 쿼리 없이 자바스크립트/타입스크립트 코드로 데이터베이스 작업을 수행할 수 있습니다.

#### **실행 흐름 (Execution Flow)**
1. **엔터티 정의**: `User` 클래스는 `@Entity('users')`로 정의되어 `users` 테이블과 연결됩니다.
2. **레포지토리 주입**: `UsersService`는 `UsersModule`의 `TypeOrmModule.forFeature([User])` 설정 덕분에 `User` 엔터티에 대한 레포지토리를 주입받을 수 있습니다.

```typescript
// src/users/users.service.ts
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './user.entity';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>, // TypeORM이 주입
  ) {}

  async register(userData: CreateUserDto) {
    const existingUser = await this.userRepository.findOneBy({ email: userData.email });
    const newUser = this.userRepository.create(userData);
    await this.userRepository.save(newUser); // INSERT 쿼리 실행
  }
}
```

- **`@InjectRepository(User)`**: TypeORM이 `User` 엔터티를 다루는 `Repository` 객체를 생성하여 `userRepository` 변수에 주입합니다.
- **`this.userRepository.save()`**: 이 메서드가 호출되면, TypeORM은 `INSERT` SQL 쿼리를 생성하여 데이터베이스에 실행합니다.

---

### 4. 가드 (Guard)와 Passport 전략 (Strategy) - 인증

#### **개념 (Concept)**
**가드(`@UseGuards`)**는 라우트 핸들러가 실행되기 전에 특정 조건을 검사하는 역할을 합니다. **Passport 전략**은 JWT 토큰 검증과 같은 실제 인증 로직을 담고 있습니다. 이 둘을 조합하여 특정 라우트에 대한 접근 권한을 제어합니다.

#### **실행 흐름 (Execution Flow)**
1. **요청 발생**: 인증이 필요한 `/users/me` 엔드포인트로 요청이 들어옵니다.
2. **가드 실행**: 컨트롤러 메서드에 `@UseGuards(JwtAuthGuard)`가 붙어있으므로, `JwtAuthGuard`가 먼저 실행됩니다.

```typescript
// src/users/users.controller.ts
@UseGuards(JwtAuthGuard) // 이 가드가 먼저 실행됩니다.
@Get('me')
getMe(@Req() req) {
  return this.usersService.findOneById(req.user.id);
}
```

3. **전략(Strategy) 실행**: `JwtAuthGuard`는 내부적으로 `JwtStrategy`를 실행시킵니다.
   - `JwtStrategy`는 요청 헤더에서 `Bearer` 토큰을 추출하고, 토큰의 유효성을 `.env` 파일의 `ACCESS_SECRET_KEY`로 검증합니다.
   - 검증이 성공하면, `validate` 메서드가 실행됩니다.

```typescript
// src/auth/jwt.strategy.ts
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  async validate(payload: any) {
    // 토큰이 유효하면 이 메서드가 실행됩니다.
    return { id: payload.sub, email: payload.email, role: payload.role };
  }
}
```

4. **핸들러 실행**: `validate`가 성공적으로 값을 반환하면, 가드는 요청을 통과시키고 `getMe` 메서드가 실행됩니다. 이때 `@Req() req` 객체 안에는 `req.user`에 `validate` 메서드가 반환한 값이 들어있습니다.

---

### 5. 가드 (Guard)와 커스텀 데코레이터 - 인가

#### **개념 (Concept)**
인증(로그인 여부)뿐만 아니라, 특정 역할(예: 'admin')을 가진 사용자인지 확인하는 것을 **인가**라고 합니다. **커스텀 데코레이터(`@Roles`)**로 필요한 역할을 명시하고, **RolesGuard**가 해당 역할을 사용자가 가지고 있는지 검사합니다.

#### **실행 흐름 (Execution Flow)**
1. **요청 발생 및 가드 실행**: `/users/:id/role` 요청이 들어오면, `@UseGuards(JwtAuthGuard, RolesGuard)`에 따라 `JwtAuthGuard`가 먼저 실행되고, 성공하면 `RolesGuard`가 실행됩니다.

```typescript
// src/users/users.controller.ts
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles('admin') // 이 라우트에는 'admin' 역할이 필요하다고 메타데이터를 설정합니다.
@Patch(':id/role')
updateUserRole(...) { /* ... */ }
```

2. **메타데이터 조회**: `RolesGuard`는 `Reflector`를 사용해 `@Roles('admin')` 데코레이터가 설정한 메타데이터('admin')를 읽어옵니다.
3. **권한 검사**: `RolesGuard`는 `JwtStrategy`가 `req.user`에 넣어준 사용자의 역할(`user.role`)과 `@Roles`가 요구하는 역할('admin')을 비교합니다.

```typescript
// src/auth/roles.guard.ts
canActivate(context: ExecutionContext): boolean {
  const requiredRoles = this.reflector.getAllAndOverride<string[]>(...);
  const { user } = context.switchToHttp().getRequest();
  return requiredRoles.some((role) => user.role?.includes(role));
}
```

4. **결과**: `true`가 반환되면 핸들러가 실행되고, `false`가 반환되면 NestJS는 `403 Forbidden` 에러를 응답합니다.

---

### 6. 파이프 (Pipe)와 DTO (Data Transfer Object)

#### **개념 (Concept)**
**DTO**는 계층 간 데이터 전송에 사용되는 객체로, 요청 본문의 형태를 정의합니다. **파이프(`@Pipe`)**는 라우트 핸들러로 들어오는 데이터를 변환하거나 유효성을 검사하는 역할을 합니다. `ValidationPipe`는 DTO에 `class-validator`로 정의된 규칙에 따라 자동으로 요청 데이터를 검증합니다.

#### **실행 흐름 (Execution Flow)**
1. **요청 발생**: `POST /users/register` 요청이 들어옵니다.
2. **파이프 실행**: `main.ts`에 `app.useGlobalPipes(new ValidationPipe())`가 설정되어 있으므로, `ValidationPipe`가 컨트롤러에 도달하기 전에 실행됩니다.
3. **DTO 기반 검증**: `ValidationPipe`는 `register` 메서드의 `@Body()`에 명시된 `CreateUserDto`를 확인합니다.

```typescript
// src/users/users.controller.ts
@Post('register')
register(@Body() createUserDto: CreateUserDto) { // 이 DTO를 기준으로 검증합니다.
  return this.usersService.register(createUserDto);
}
```

4. **유효성 검사**: `ValidationPipe`는 요청 본문을 `CreateUserDto`에 정의된 규칙과 비교합니다.
5. **핸들러 실행**: 검증을 통과하면, 유효한 데이터가 담긴 `createUserDto` 객체가 `register` 메서드로 전달됩니다.

---

### 7. 예외 필터 (Exception Filter)

#### **개념 (Concept)**
애플리케이션 전역에서 발생하는 처리되지 않은 모든 예외를 잡아내어, 일관된 형식의 에러 응답을 클라이언트에게 보내주는 역할을 합니다.

#### **실행 흐름 (Execution Flow)**
1. **예외 발생**: 서비스 로직 등에서 `throw new NotFoundException('사용자를 찾을 수 없습니다.');`와 같이 예외가 발생합니다.
2. **필터 실행**: `main.ts`에 `app.useGlobalFilters(new AllExceptionsFilter())`가 설정되어 있으므로, `AllExceptionsFilter`가 이 예외를 가로챕니다.
3. **에러 응답 생성**: `catch` 메서드가 실행되어, 발생한 예외의 종류(`HttpException`인지 아닌지)에 따라 상태 코드와 메시지를 결정하고, 정해진 JSON 형식으로 응답을 만듭니다.

```typescript
// src/common/filters/http-exception.filter.ts
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const status = exception instanceof HttpException ? exception.getStatus() : 500;
    const message = exception instanceof HttpException ? exception.getResponse() : '...';
    // ...
  }
}
```

이 덕분에 어떤 에러가 발생하든 클라이언트는 항상 일관된 형식의 에러 메시지를 받게 됩니다.